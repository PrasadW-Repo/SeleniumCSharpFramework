using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using OpenQA.Selenium;
using OpenQA.Selenium.Support.UI;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices.JavaScript;
using System.Text;
using System.Text.Json.Nodes;

namespace SeleniumCSharpProject.utilities
{
    public class Utils

    {
        /// <summary>
        /// Reads a JSON file from disk and returns the deserialized value (JObject or JArray) as a dynamic.
        /// Uses <see cref="JsonConvert.DeserializeObject(string)"/> and validates the result is not null.
        /// Throws an <see cref="InvalidOperationException"/> with context if reading or parsing fails.
        /// </summary>
        /// <param name="fileName">Path to the JSON file.</param>
        /// <returns>Deserialized JSON as dynamic (JObject or JArray).</returns>
        public static dynamic ReadJSON(String fileName)
        {
            try
            {
                // Read the file contents
                var json = File.ReadAllText(fileName);

                // Deserialize using JsonConvert (non-generic) as requested
                var parsed = JsonConvert.DeserializeObject(json);

                if (parsed == null)
                {
                    throw new InvalidOperationException($"The JSON in '{fileName}' did not deserialize to a valid JSON object or array.");
                }

                return parsed;
            }
            catch (Exception ex)
            {
                // Wrap and rethrow with additional context to make failures easier to diagnose.
                throw new InvalidOperationException($"Failed to read or parse JSON file '{fileName}'.", ex);
            }
        }

        public static void WaitForElementToAppear(By element, int time)
        {
            // Placeholder - implementation requires an IWebDriver reference to create a WebDriverWait.
            // Keep as a stub to be implemented from caller context where driver is available.
        }

    }
}
